// ================================================================================================
// ============================= Google Apps Script Backend (Code.gs) =============================
//
// INSTRUCTIONS:
//
// 1. Ensure your Google Sheet has 8 tabs with these exact English names:
//    - Products
//    - Categories
//    - Customers
//    - Orders
//    - OrderItems
//    - Expenses
//    - CustomerSelections
//    - CustomerSelectionItems
//
// 2. VERY IMPORTANT: The first row of each sheet MUST have the following English headers exactly.
//    Please copy and paste these headers precisely to ensure the code works correctly.
//
//    - Products sheet headers:
//      id, name, categoryId, description, price, memberPrice, imageUrl, isAvailable, points
//
//    - Categories sheet headers:
//      id, name
//
//    - Customers sheet headers:
//      id, name, address, phone, whatsapp, email
//
//    - Orders sheet headers:
//      id, customerId, customerName, totalPrice, totalPoints, createdAt
//
//    - OrderItems sheet headers:
//      orderId, productId, name, price, quantity, points
//
//    - Expenses sheet headers:
//      id, description, amount, date
//
//    - CustomerSelections sheet headers:
//      id, customerName, customerPhone, customerEmail, createdAt, status
//
//    - CustomerSelectionItems sheet headers:
//      selectionId, productId, name, price, quantity, points
//
// 3. In Google Sheets, go to Extensions > Apps Script.
// 4. Delete any existing code in `Code.gs` and paste this entire script.
// 5. Click Deploy > New deployment.
// 6. Select "Web app" as the deployment type.
// 7. In the settings:
//    - For "Execute as", select "Me".
//    - For "Who has access", select "Anyone".
// 8. Click "Deploy". Authorize the script when prompted.
// 9. Copy the Web app URL and paste it into the `GOOGLE_SCRIPT_URL` variable in your frontend code
//    (in the file `context/AppContext.tsx`).
//
// ================================================================================================

// --- CONFIGURATION ---
const SPREADSHEET_ID = SpreadsheetApp.getActiveSpreadsheet().getId();

const SHEET_MAPPING = {
  PRODUCTS: 'Products',
  CATEGORIES: 'Categories',
  CUSTOMERS: 'Customers',
  ORDERS: 'Orders',
  ORDER_ITEMS: 'OrderItems',
  EXPENSES: 'Expenses',
  CUSTOMER_SELECTIONS: 'CustomerSelections',
  CUSTOMER_SELECTION_ITEMS: 'CustomerSelectionItems'
};

const REQUIRED_SCHEMA = {
  'Products': ['id', 'name', 'categoryId', 'description', 'price', 'memberPrice', 'imageUrl', 'isAvailable', 'points'],
  'Categories': ['id', 'name'],
  'Customers': ['id', 'name', 'address', 'phone', 'whatsapp', 'email'],
  'Orders': ['id', 'customerId', 'customerName', 'totalPrice', 'totalPoints', 'createdAt'],
  'OrderItems': ['orderId', 'productId', 'name', 'price', 'quantity', 'points'],
  'Expenses': ['id', 'description', 'amount', 'date'],
  'CustomerSelections': ['id', 'customerName', 'customerPhone', 'customerEmail', 'createdAt', 'status'],
  'CustomerSelectionItems': ['selectionId', 'productId', 'name', 'price', 'quantity', 'points']
};


// --- CORE FUNCTIONS ---

/**
 * Reusable function to fetch and structure all data.
 */
function _getAllData() {
  const data = {
    products: getSheetData(SHEET_MAPPING.PRODUCTS),
    categories: getSheetData(SHEET_MAPPING.CATEGORIES),
    customers: getSheetData(SHEET_MAPPING.CUSTOMERS),
    orders: getSheetData(SHEET_MAPPING.ORDERS),
    expenses: getSheetData(SHEET_MAPPING.EXPENSES),
    customerSelections: getSheetData(SHEET_MAPPING.CUSTOMER_SELECTIONS),
  };
  
  const orderItems = getSheetData(SHEET_MAPPING.ORDER_ITEMS);
  data.orders.forEach(order => {
      order.items = orderItems.filter(item => item.orderId === order.id);
  });

  const selectionItems = getSheetData(SHEET_MAPPING.CUSTOMER_SELECTION_ITEMS);
  data.customerSelections.forEach(selection => {
      selection.items = selectionItems.filter(item => item.selectionId === selection.id);
  });

  return { status: 'success', data: data };
}


/**
 * Main entry point for GET requests. Can be used for testing.
 */
function doGet(e) {
  return createJsonResponse({ status: 'success', message: 'API is running.' });
}

/**
 * Main entry point for POST requests. Acts as a router for various actions.
 */
function doPost(e) {
  const lock = LockService.getScriptLock();
  lock.waitLock(30000); 
  
  try {
    if (!e.postData || !e.postData.contents) {
      throw new Error("No data received in POST request.");
    }
    const request = JSON.parse(e.postData.contents);
    const action = request.action;
    const payload = request.payload || {};

    if (!action) throw new Error("Action not specified in request body.");

    switch (action) {
      case 'getAllData': return createJsonResponse(_getAllData());
      case 'getExchangeRate': return handleGetExchangeRate();
      case 'addProduct': return handleAddProduct(payload);
      case 'updateProduct': return handleUpdateProduct(payload);
      case 'deleteProduct': return handleDeleteProduct(payload);
      case 'toggleProductAvailability': return handleToggleProductAvailability(payload);
      case 'addOrder': return handleAddOrder(payload);
      case 'addExpense': return handleAddExpense(payload);
      case 'deleteExpense': return handleDeleteExpense(payload);
      case 'addCustomerSelection': return handleAddCustomerSelection(payload);
      case 'processSelection': return handleProcessSelection(payload);
      case 'runHealthCheck': return handleHealthCheck();
      default: throw new Error(`Unknown action: ${action}`);
    }
  } catch (error) {
    Logger.log(error.stack);
    return createJsonResponse({ status: 'error', message: error.message, stack: error.stack });
  } finally {
    lock.releaseLock();
  }
}

// --- ACTION HANDLERS ---

function handleGetExchangeRate() {
  try {
    const response = UrlFetchApp.fetch('https://api.exchangerate-api.com/v4/latest/USD');
    const data = JSON.parse(response.getContentText());
    const rate = data.rates.ILS;
    if (!rate) {
      Logger.log('ILS rate not found in API response. Using fallback.');
      return createJsonResponse({ status: 'success', data: { rate: 3.7 } });
    }
    return createJsonResponse({ status: 'success', data: { rate: rate } });
  } catch (error) {
    Logger.log('Failed to fetch exchange rate from API: ' + error.toString() + '. Using fallback.');
    return createJsonResponse({ status: 'success', data: { rate: 3.7 } }); 
  }
}

function handleAddProduct(payload) {
    const newProduct = { ...payload, id: generateUniqueId(), isAvailable: true };
    
    // If imageUrl is a base64 string, save it to Google Drive and replace with the URL
    if (newProduct.imageUrl && newProduct.imageUrl.startsWith('data:image')) {
        const fileName = `product_${newProduct.id}_${new Date().getTime()}`;
        newProduct.imageUrl = _saveBase64ImageToDrive(newProduct.imageUrl, fileName);
    }

    appendRowFromObject(SpreadsheetApp.openById(SPREADSHEET_ID).getSheetByName(SHEET_MAPPING.PRODUCTS), newProduct);
    return createJsonResponse({ status: 'success', data: newProduct });
}

function handleUpdateProduct(payload) {
    // Get the existing product to check the old imageUrl
    const sheet = SpreadsheetApp.openById(SPREADSHEET_ID).getSheetByName(SHEET_MAPPING.PRODUCTS);
    const headers = getHeaders(sheet);
    const data = sheet.getDataRange().getValues();
    const idColumnIndex = headers.indexOf('id');
    const rowIndex = data.findIndex(row => String(row[idColumnIndex]).trim() == String(payload.id).trim());

    if (rowIndex < 1) { // not found
      throw new Error(`Product with ID ${payload.id} not found for update.`);
    }

    const existingProduct = mapRowToAnObject(data[rowIndex], headers);
    const oldImageUrl = existingProduct.imageUrl;
    const newImageUrl = payload.imageUrl;
    
    // If imageUrl is a new base64 string, save it and delete the old one.
    if (newImageUrl && newImageUrl.startsWith('data:image')) {
        const fileName = `product_${payload.id}_${new Date().getTime()}`;
        payload.imageUrl = _saveBase64ImageToDrive(newImageUrl, fileName);
        _deleteImageFromDrive(oldImageUrl);
    }

    updateRowById(SHEET_MAPPING.PRODUCTS, payload.id, payload);
    return createJsonResponse({ status: 'success', data: payload });
}

function handleDeleteProduct(payload) {
    if (!payload || !payload.productId) throw new Error("Product ID is missing.");
    // Also delete the image from Drive if it exists
    const sheet = SpreadsheetApp.openById(SPREADSHEET_ID).getSheetByName(SHEET_MAPPING.PRODUCTS);
    const headers = getHeaders(sheet);
    const data = sheet.getDataRange().getValues();
    const idColumnIndex = headers.indexOf('id');
    const rowIndex = data.findIndex(row => String(row[idColumnIndex]).trim() == String(payload.productId).trim());
    if (rowIndex > 0) {
        const productToDelete = mapRowToAnObject(data[rowIndex], headers);
        _deleteImageFromDrive(productToDelete.imageUrl);
    }

    deleteRowById(SHEET_MAPPING.PRODUCTS, payload.productId);
    return createJsonResponse({ status: 'success' });
}

function handleToggleProductAvailability(payload) {
    const { productId } = payload;
    if (!productId) throw new Error("Product ID is required.");

    const sheet = SpreadsheetApp.openById(SPREADSHEET_ID).getSheetByName(SHEET_MAPPING.PRODUCTS);
    const headers = getHeaders(sheet);
    const data = sheet.getDataRange().getValues();
    
    const idColumnIndex = headers.indexOf('id');
    const isAvailableColumnIndex = headers.indexOf('isAvailable');
    if (idColumnIndex === -1 || isAvailableColumnIndex === -1) throw new Error("Required columns ('id', 'isAvailable') not found in Products sheet.");

    const rowIndex = data.findIndex(row => String(row[idColumnIndex]).trim() == String(productId).trim());

    if (rowIndex > 0) {
        const currentValue = data[rowIndex][isAvailableColumnIndex];
        const newValue = !(currentValue === true || String(currentValue).toLowerCase() === 'true');
        sheet.getRange(rowIndex + 1, isAvailableColumnIndex + 1).setValue(newValue);
        return createJsonResponse({ status: 'success', data: { productId: productId, isAvailable: newValue } });
    } else {
        throw new Error(`Product with ID ${productId} not found.`);
    }
}


function handleAddOrder(payload) {
    const { customerData, items } = payload;
    
    const customersSheet = SpreadsheetApp.openById(SPREADSHEET_ID).getSheetByName(SHEET_MAPPING.CUSTOMERS);
    const headers = getHeaders(customersSheet);
    const phoneColumnIndex = headers.map(h => h.toLowerCase()).indexOf('phone');
    const customersData = customersSheet.getDataRange().getValues();
    
    let customerRowIndex = -1;
    if (customerData.phone && phoneColumnIndex !== -1) {
      customerRowIndex = customersData.findIndex(row => row[phoneColumnIndex] == customerData.phone);
    }
    
    let customer;
    if (customerRowIndex !== -1) {
        const existingCustomer = mapRowToAnObject(customersData[customerRowIndex], headers);
        customer = { ...existingCustomer, ...customerData };
        updateRowById(SHEET_MAPPING.CUSTOMERS, customer.id, customer);
    } else {
        customer = { ...customerData, id: generateUniqueId() };
        appendRowFromObject(customersSheet, customer);
    }
    
    const ordersSheet = SpreadsheetApp.openById(SPREADSHEET_ID).getSheetByName(SHEET_MAPPING.ORDERS);
    const newOrderId = generateUniqueId();
    const totalPrice = items.reduce((sum, item) => sum + item.price * item.quantity, 0);
    const totalPoints = items.reduce((sum, item) => sum + ((item.points || 0) * item.quantity), 0);
    
    const newOrder = {
        id: newOrderId,
        customerId: customer.id,
        customerName: customer.name,
        totalPrice: totalPrice,
        totalPoints: totalPoints,
        createdAt: new Date().toISOString()
    };
    appendRowFromObject(ordersSheet, newOrder);

    const orderItemsSheet = SpreadsheetApp.openById(SPREADSHEET_ID).getSheetByName(SHEET_MAPPING.ORDER_ITEMS);
    items.forEach(item => {
        const newOrderItem = { ...item, orderId: newOrderId };
        appendRowFromObject(orderItemsSheet, newOrderItem);
    });

    return createJsonResponse({ status: 'success', data: { newOrder: { ...newOrder, items }, updatedCustomer: customer } });
}

function handleAddExpense(payload) {
    const newExpense = { ...payload, id: generateUniqueId(), date: new Date(payload.date).toISOString() };
    appendRowFromObject(SpreadsheetApp.openById(SPREADSHEET_ID).getSheetByName(SHEET_MAPPING.EXPENSES), newExpense);
    return createJsonResponse({ status: 'success', data: newExpense });
}

function handleDeleteExpense(payload) {
    deleteRowById(SHEET_MAPPING.EXPENSES, payload.expenseId);
    return createJsonResponse({ status: 'success' });
}

function handleAddCustomerSelection(payload) {
    const selectionsSheet = SpreadsheetApp.openById(SPREADSHEET_ID).getSheetByName(SHEET_MAPPING.CUSTOMER_SELECTIONS);
    const newId = generateUniqueId();
    const newSelection = { ...payload, items: undefined, id: newId, createdAt: new Date().toISOString(), status: 'pending' };
    appendRowFromObject(selectionsSheet, newSelection);
    
    const selectionItemsSheet = SpreadsheetApp.openById(SPREADSHEET_ID).getSheetByName(SHEET_MAPPING.CUSTOMER_SELECTION_ITEMS);
    payload.items.forEach(item => {
        const newSelectionItem = { ...item, selectionId: newId };
        appendRowFromObject(selectionItemsSheet, newSelectionItem);
    });

    return createJsonResponse({ status: 'success', data: newSelection });
}

function handleProcessSelection(payload) {
    updateRowById(SHEET_MAPPING.CUSTOMER_SELECTIONS, payload.selectionId, { status: 'processed' });
    return createJsonResponse({ status: 'success' });
}

function handleHealthCheck() {
  const results = [];
  const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
  const allSheets = spreadsheet.getSheets().map(s => s.getName());

  for (const sheetName in REQUIRED_SCHEMA) {
    if (allSheets.includes(sheetName)) {
      results.push({ check: `Sheet '${sheetName}'`, status: 'success', details: `Sheet exists.` });
      
      const sheet = spreadsheet.getSheetByName(sheetName);
      const actualHeaders = getHeaders(sheet);
      const requiredHeaders = REQUIRED_SCHEMA[sheetName];
      
      const missingHeaders = requiredHeaders.filter(h => !actualHeaders.includes(h));

      if (missingHeaders.length === 0) {
        results.push({ check: `Headers for '${sheetName}'`, status: 'success', details: 'All required headers are present.' });
      } else {
        results.push({ check: `Headers for '${sheetName}'`, status: 'error', details: `Missing headers: ${missingHeaders.join(', ')}` });
      }

    } else {
      results.push({ check: `Sheet '${sheetName}'`, status: 'error', details: `Sheet is missing.` });
    }
  }
  return createJsonResponse({ status: 'success', data: results });
}

// --- IMAGE HANDLING HELPERS ---

/**
 * Saves a base64 encoded image to a specific folder in Google Drive and returns its public URL.
 */
function _saveBase64ImageToDrive(base64DataUrl, fileName) {
  const FOLDER_NAME = 'DXN_App_Images';
  let folders = DriveApp.getFoldersByName(FOLDER_NAME);
  let folder;

  if (folders.hasNext()) {
    folder = folders.next();
  } else {
    folder = DriveApp.createFolder(FOLDER_NAME);
  }
  
  folder.setSharing(DriveApp.Access.ANYONE_WITH_LINK, DriveApp.Permission.VIEW);

  const parts = base64DataUrl.split(',');
  const mimeType = parts[0].match(/:(.*?);/)[1] || 'image/jpeg';
  const base64Data = parts[1];
  const decodedData = Utilities.base64Decode(base64Data);
  const blob = Utilities.newBlob(decodedData, mimeType, fileName);

  const file = folder.createFile(blob);
  file.setSharing(DriveApp.Access.ANYONE_WITH_LINK, DriveApp.Permission.VIEW); 

  const fileId = file.getId();
  const imageUrl = `https://lh3.googleusercontent.com/d/${fileId}`;

  return imageUrl;
}

/**
 * Moves a previously uploaded image from Google Drive to the trash.
 */
function _deleteImageFromDrive(imageUrl) {
  if (imageUrl && imageUrl.includes('lh3.googleusercontent.com/d/')) {
    try {
      const fileId = imageUrl.split('/d/')[1].split('/')[0];
      DriveApp.getFileById(fileId).setTrashed(true);
    } catch (e) {
      Logger.log(`Could not delete old image file with URL ${imageUrl}: ${e.toString()}`);
    }
  }
}


// --- HELPER FUNCTIONS ---

function createJsonResponse(obj) {
  return ContentService.createTextOutput(JSON.stringify(obj))
    .setMimeType(ContentService.MimeType.JSON);
}

function generateUniqueId() {
  return Utilities.getUuid();
}

function getHeaders(sheet) {
  if (sheet.getLastRow() === 0) return [];
  return sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0].map(h => h.toString().trim());
}

function getSheetData(sheetName) {
  const sheet = SpreadsheetApp.openById(SPREADSHEET_ID).getSheetByName(sheetName);
  if (!sheet) return [];
  
  const values = sheet.getDataRange().getValues();
  if (values.length < 2) return [];

  const headers = getHeaders(sheet);
  return values.slice(1).map(row => {
    if (row[0] === '') return null; // Skip empty rows based on ID
    return mapRowToAnObject(row, headers);
  }).filter(Boolean); // Filter out nulls
}

function mapRowToAnObject(row, headers) {
    const obj = {};
    headers.forEach((header, index) => {
        if (!header) return;
        let value = row[index];
        const lowerHeader = header.toLowerCase();

        if (['price', 'memberprice', 'amount', 'quantity', 'points', 'totalprice', 'totalpoints'].includes(lowerHeader)) {
            value = parseFloat(value) || 0;
        } else if (lowerHeader === 'isavailable') {
            value = value === true || String(value).toLowerCase() === 'true';
        } else if ((lowerHeader.includes('date') || lowerHeader.includes('createdat')) && value && !isNaN(new Date(value).getTime())) {
            value = new Date(value).toISOString();
        }
        obj[header] = value;
    });
    return obj;
}

function appendRowFromObject(sheet, obj) {
    const headers = getHeaders(sheet);
    const newRow = headers.map(header => (obj[header] !== undefined && obj[header] !== null ? obj[header] : ''));
    sheet.appendRow(newRow);
}

function updateRowById(sheetName, recordId, payload) {
    const sheet = SpreadsheetApp.openById(SPREADSHEET_ID).getSheetByName(sheetName);
    const headers = getHeaders(sheet);
    const idColumnIndex = headers.indexOf('id');
    if (idColumnIndex === -1) throw new Error(`'id' column not found in sheet "${sheetName}".`);

    const data = sheet.getDataRange().getValues();
    const rowIndex = data.findIndex(row => String(row[idColumnIndex]).trim() == String(recordId).trim());
    
    if (rowIndex > 0) {
        const existingRecord = mapRowToAnObject(data[rowIndex], headers);
        const updatedRecord = { ...existingRecord, ...payload };
        const updatedRow = headers.map(header => (updatedRecord[header] !== undefined ? updatedRecord[header] : ''));
        sheet.getRange(rowIndex + 1, 1, 1, headers.length).setValues([updatedRow]);
    } else {
        throw new Error(`Record with ID ${recordId} not found in "${sheetName}".`);
    }
}

function deleteRowById(sheetName, recordId) {
    const sheet = SpreadsheetApp.openById(SPREADSHEET_ID).getSheetByName(sheetName);
    const headers = getHeaders(sheet);
    const idColumnIndex = headers.indexOf('id');
    if (idColumnIndex === -1) throw new Error(`'id' column not found in sheet "${sheetName}".`);
    
    const data = sheet.getDataRange().getValues();
    const rowIndex = data.findIndex(row => String(row[idColumnIndex]).trim() == String(recordId).trim());
    
    if (rowIndex > 0) {
        sheet.deleteRow(rowIndex + 1);
    } else {
        throw new Error(`Record with ID ${recordId} not found in "${sheetName}".`);
    }
}